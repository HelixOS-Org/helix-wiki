import type { DocContent } from "./index";

const content: DocContent = {
  en: {
    // PageHeader
    "header.title": "Module System",
    "header.subtitle":
      "2,559 lines across 9 files â€” a hot-swappable, capability-gated module framework with ABI versioning, dependency resolution, and a full lifecycle state machine.",
    "header.badge": "MODULE FRAMEWORK",

    // Philosophy
    "philosophy.intro":
      "In Helix, the core kernel provides mechanisms â€” the module system provides policy. Schedulers, filesystems, drivers, and security modules are all loadable/unloadable at runtime:",
    "philosophy.mechanism.title": "ğŸ”§ Mechanism (Core)",
    "philosophy.policy.title": "ğŸ“‹ Policy (Modules)",

    // Core Types
    "types.intro":
      "Core types used across the module system â€” identifiers, versions, flags, states, and errors:",

    // Module Metadata
    "metadata.intro":
      "Every module declares metadata including name, version, author, ABI compatibility, dependencies, and required capabilities:",

    // Module Trait
    "trait.intro":
      "The Module trait is the contract every module must implement â€” lifecycle hooks, message handling, health checks, and state serialization for hot-reload:",

    // Module Registry
    "registry.intro":
      "The ModuleRegistry manages all loaded modules â€” discovery, dependency resolution, loading, initialization, and unloading:",

    // define_module! Macro
    "macro.intro":
      "The define_module! macro generates boilerplate for common module patterns â€” metadata, trait implementation, and registration:",

    // Module Lifecycle
    "lifecycle.intro":
      "Every module follows a strict 9-state lifecycle with 12 possible transitions. The state machine prevents invalid operations and enables clean hot-reload:",

    // Example: Round-Robin Scheduler
    "example.intro":
      "A complete example showing how a scheduler module implements both the Module trait and the Scheduler trait, with hot-reload support:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },

  fr: {
    // PageHeader
    "header.title": "SystÃ¨me de modules",
    "header.subtitle":
      "2 559 lignes rÃ©parties sur 9 fichiers â€” un cadre de modules Ã©changeables Ã  chaud, contrÃ´lÃ© par capacitÃ©s, avec versionnage ABI, rÃ©solution de dÃ©pendances et une machine Ã  Ã©tats de cycle de vie complÃ¨te.",
    "header.badge": "CADRE DE MODULES",

    // Philosophy
    "philosophy.intro":
      "Dans Helix, le noyau central fournit les mÃ©canismes â€” le systÃ¨me de modules fournit la politique. Les ordonnanceurs, systÃ¨mes de fichiers, pilotes et modules de sÃ©curitÃ© sont tous chargeables/dÃ©chargeables Ã  l'exÃ©cution :",
    "philosophy.mechanism.title": "ğŸ”§ MÃ©canisme (Noyau)",
    "philosophy.policy.title": "ğŸ“‹ Politique (Modules)",

    // Core Types
    "types.intro":
      "Types de base utilisÃ©s dans tout le systÃ¨me de modules â€” identifiants, versions, drapeaux, Ã©tats et erreurs :",

    // Module Metadata
    "metadata.intro":
      "Chaque module dÃ©clare des mÃ©tadonnÃ©es incluant le nom, la version, l'auteur, la compatibilitÃ© ABI, les dÃ©pendances et les capacitÃ©s requises :",

    // Module Trait
    "trait.intro":
      "Le trait Module est le contrat que chaque module doit implÃ©menter â€” hooks de cycle de vie, gestion des messages, vÃ©rifications de santÃ© et sÃ©rialisation d'Ã©tat pour le rechargement Ã  chaud :",

    // Module Registry
    "registry.intro":
      "Le ModuleRegistry gÃ¨re tous les modules chargÃ©s â€” dÃ©couverte, rÃ©solution de dÃ©pendances, chargement, initialisation et dÃ©chargement :",

    // define_module! Macro
    "macro.intro":
      "La macro define_module! gÃ©nÃ¨re le code standard pour les motifs de modules courants â€” mÃ©tadonnÃ©es, implÃ©mentation du trait et enregistrement :",

    // Module Lifecycle
    "lifecycle.intro":
      "Chaque module suit un cycle de vie strict Ã  9 Ã©tats avec 12 transitions possibles. La machine Ã  Ã©tats empÃªche les opÃ©rations invalides et permet un rechargement Ã  chaud propre :",

    // Example: Round-Robin Scheduler
    "example.intro":
      "Un exemple complet montrant comment un module d'ordonnancement implÃ©mente Ã  la fois le trait Module et le trait Scheduler, avec prise en charge du rechargement Ã  chaud :",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },

  es: {
    "header.title": "Sistema de MÃ³dulos",
    "header.subtitle":
      "2.559 lÃ­neas en 9 archivos â€” un marco de mÃ³dulos intercambiables en caliente, controlado por capacidades, con versionado ABI, resoluciÃ³n de dependencias y una mÃ¡quina de estados de ciclo de vida completa.",
    "header.badge": "MARCO DE MÃ“DULOS",
    "philosophy.intro":
      "En Helix, el nÃºcleo del kernel proporciona mecanismos â€” el sistema de mÃ³dulos proporciona polÃ­ticas. Los planificadores, sistemas de archivos, controladores y mÃ³dulos de seguridad son todos cargables/descargables en tiempo de ejecuciÃ³n:",
    "philosophy.mechanism.title": "ğŸ”§ Mecanismo (NÃºcleo)",
    "philosophy.policy.title": "ğŸ“‹ PolÃ­tica (MÃ³dulos)",
    "types.intro":
      "Tipos centrales usados en todo el sistema de mÃ³dulos â€” identificadores, versiones, banderas, estados y errores:",
    "metadata.intro":
      "Cada mÃ³dulo declara metadatos incluyendo nombre, versiÃ³n, autor, compatibilidad ABI, dependencias y capacidades requeridas:",
    "trait.intro":
      "El trait Module es el contrato que todo mÃ³dulo debe implementar â€” hooks de ciclo de vida, manejo de mensajes, chequeos de salud y serializaciÃ³n de estado para recarga en caliente:",
    "registry.intro":
      "El ModuleRegistry gestiona todos los mÃ³dulos cargados â€” descubrimiento, resoluciÃ³n de dependencias, carga, inicializaciÃ³n y descarga:",
    "macro.intro":
      "La macro define_module! genera el cÃ³digo estÃ¡ndar para patrones comunes de mÃ³dulos â€” metadatos, implementaciÃ³n del trait y registro:",
    "lifecycle.intro":
      "Cada mÃ³dulo sigue un ciclo de vida estricto de 9 estados con 12 transiciones posibles. La mÃ¡quina de estados previene operaciones invÃ¡lidas y permite una recarga en caliente limpia:",
    "example.intro":
      "Un ejemplo completo que muestra cÃ³mo un mÃ³dulo de planificador implementa tanto el trait Module como el trait Scheduler, con soporte de recarga en caliente:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },

  de: {
    "header.title": "Modulsystem",
    "header.subtitle":
      "2.559 Zeilen in 9 Dateien â€” ein Hot-Swap-fÃ¤higes, Capability-gesteuertes Modul-Framework mit ABI-Versionierung, AbhÃ¤ngigkeitsauflÃ¶sung und einem vollstÃ¤ndigen Lebenszyklus-Zustandsautomaten.",
    "header.badge": "MODUL-FRAMEWORK",
    "philosophy.intro":
      "In Helix stellt der Kernel-Kern Mechanismen bereit â€” das Modulsystem liefert die Richtlinien. Scheduler, Dateisysteme, Treiber und Sicherheitsmodule sind alle zur Laufzeit ladbar/entladbar:",
    "philosophy.mechanism.title": "ğŸ”§ Mechanismus (Kern)",
    "philosophy.policy.title": "ğŸ“‹ Richtlinie (Module)",
    "types.intro":
      "Kerntypen, die im gesamten Modulsystem verwendet werden â€” Bezeichner, Versionen, Flags, ZustÃ¤nde und Fehler:",
    "metadata.intro":
      "Jedes Modul deklariert Metadaten einschlieÃŸlich Name, Version, Autor, ABI-KompatibilitÃ¤t, AbhÃ¤ngigkeiten und erforderliche FÃ¤higkeiten:",
    "trait.intro":
      "Das Module-Trait ist der Vertrag, den jedes Modul implementieren muss â€” Lebenszyklus-Hooks, Nachrichtenbehandlung, GesundheitsprÃ¼fungen und Zustandsserialisierung fÃ¼r Hot-Reload:",
    "registry.intro":
      "Die ModuleRegistry verwaltet alle geladenen Module â€” Erkennung, AbhÃ¤ngigkeitsauflÃ¶sung, Laden, Initialisierung und Entladen:",
    "macro.intro":
      "Das define_module!-Makro generiert Boilerplate fÃ¼r gÃ¤ngige Modulmuster â€” Metadaten, Trait-Implementierung und Registrierung:",
    "lifecycle.intro":
      "Jedes Modul folgt einem strikten 9-Zustands-Lebenszyklus mit 12 mÃ¶glichen ÃœbergÃ¤ngen. Der Zustandsautomat verhindert ungÃ¼ltige Operationen und ermÃ¶glicht sauberes Hot-Reload:",
    "example.intro":
      "Ein vollstÃ¤ndiges Beispiel, das zeigt, wie ein Scheduler-Modul sowohl das Module-Trait als auch das Scheduler-Trait implementiert, mit Hot-Reload-UnterstÃ¼tzung:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },




  pt: {
    "header.title": "Sistema de MÃ³dulos",
    "header.subtitle":
      "2.559 linhas em 9 arquivos â€” um framework de mÃ³dulos com hot-swap, controlado por capacidades, com versionamento ABI, resoluÃ§Ã£o de dependÃªncias e uma mÃ¡quina de estados de ciclo de vida completa.",
    "header.badge": "FRAMEWORK DE MÃ“DULOS",
    "philosophy.intro":
      "No Helix, o nÃºcleo do kernel fornece mecanismos â€” o sistema de mÃ³dulos fornece polÃ­ticas. Escalonadores, sistemas de arquivos, drivers e mÃ³dulos de seguranÃ§a sÃ£o todos carregÃ¡veis/descarregÃ¡veis em tempo de execuÃ§Ã£o:",
    "philosophy.mechanism.title": "ğŸ”§ Mecanismo (NÃºcleo)",
    "philosophy.policy.title": "ğŸ“‹ PolÃ­tica (MÃ³dulos)",
    "types.intro":
      "Tipos centrais usados em todo o sistema de mÃ³dulos â€” identificadores, versÃµes, flags, estados e erros:",
    "metadata.intro":
      "Cada mÃ³dulo declara metadados incluindo nome, versÃ£o, autor, compatibilidade ABI, dependÃªncias e capacidades necessÃ¡rias:",
    "trait.intro":
      "O trait Module Ã© o contrato que todo mÃ³dulo deve implementar â€” hooks de ciclo de vida, tratamento de mensagens, verificaÃ§Ãµes de saÃºde e serializaÃ§Ã£o de estado para hot-reload:",
    "registry.intro":
      "O ModuleRegistry gerencia todos os mÃ³dulos carregados â€” descoberta, resoluÃ§Ã£o de dependÃªncias, carregamento, inicializaÃ§Ã£o e descarregamento:",
    "macro.intro":
      "A macro define_module! gera boilerplate para padrÃµes comuns de mÃ³dulos â€” metadados, implementaÃ§Ã£o de trait e registro:",
    "lifecycle.intro":
      "Cada mÃ³dulo segue um ciclo de vida rigoroso de 9 estados com 12 transiÃ§Ãµes possÃ­veis. A mÃ¡quina de estados previne operaÃ§Ãµes invÃ¡lidas e permite hot-reload limpo:",
    "example.intro":
      "Um exemplo completo mostrando como um mÃ³dulo escalonador implementa tanto o trait Module quanto o trait Scheduler, com suporte a hot-reload:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },

  ru: {
    "header.title": "Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ğ¼Ğ¾Ğ´ÑƒĞ»ĞµĞ¹",
    "header.subtitle":
      "2 559 ÑÑ‚Ñ€Ğ¾Ğº Ğ² 9 Ñ„Ğ°Ğ¹Ğ»Ğ°Ñ… â€” Ñ„Ñ€ĞµĞ¹Ğ¼Ğ²Ğ¾Ñ€Ğº Ğ¼Ğ¾Ğ´ÑƒĞ»ĞµĞ¹ Ñ Ğ³Ğ¾Ñ€ÑÑ‡ĞµĞ¹ Ğ·Ğ°Ğ¼ĞµĞ½Ğ¾Ğ¹ Ğ¸ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ¾Ğ»ĞµĞ¼ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğ¼Ğ¾Ñ‡Ğ¸Ğ¹, Ñ Ğ²ĞµÑ€ÑĞ¸Ğ¾Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸ĞµĞ¼ ABI, Ñ€Ğ°Ğ·Ñ€ĞµÑˆĞµĞ½Ğ¸ĞµĞ¼ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹ Ğ¸ Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğ¼ ĞºĞ¾Ğ½ĞµÑ‡Ğ½Ñ‹Ğ¼ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¾Ğ¼ Ğ¶Ğ¸Ğ·Ğ½ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ñ†Ğ¸ĞºĞ»Ğ°.",
    "header.badge": "Ğ¤Ğ Ğ•Ğ™ĞœĞ’ĞĞ Ğš ĞœĞĞ”Ğ£Ğ›Ğ•Ğ™",
    "philosophy.intro":
      "Ğ’ Helix ÑĞ´Ñ€Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ÑĞµÑ‚ Ğ¼ĞµÑ…Ğ°Ğ½Ğ¸Ğ·Ğ¼Ñ‹ â€” ÑĞ¸ÑÑ‚ĞµĞ¼Ğ° Ğ¼Ğ¾Ğ´ÑƒĞ»ĞµĞ¹ Ğ¿Ñ€ĞµĞ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ÑĞµÑ‚ Ğ¿Ğ¾Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ¸. ĞŸĞ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸ĞºĞ¸, Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²Ñ‹Ğµ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹, Ğ´Ñ€Ğ°Ğ¹Ğ²ĞµÑ€Ñ‹ Ğ¸ Ğ¼Ğ¾Ğ´ÑƒĞ»Ğ¸ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸ â€” Ğ²ÑĞµ Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶Ğ°ĞµĞ¼Ñ‹Ğµ/Ğ²Ñ‹Ğ³Ñ€ÑƒĞ¶Ğ°ĞµĞ¼Ñ‹Ğµ Ğ²Ğ¾ Ğ²Ñ€ĞµĞ¼Ñ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ:",
    "philosophy.mechanism.title": "ğŸ”§ ĞœĞµÑ…Ğ°Ğ½Ğ¸Ğ·Ğ¼ (Ğ¯Ğ´Ñ€Ğ¾)",
    "philosophy.policy.title": "ğŸ“‹ ĞŸĞ¾Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ° (ĞœĞ¾Ğ´ÑƒĞ»Ğ¸)",
    "types.intro":
      "ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ Ñ‚Ğ¸Ğ¿Ñ‹, Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼Ñ‹Ğµ Ğ² ÑĞ¸ÑÑ‚ĞµĞ¼Ğµ Ğ¼Ğ¾Ğ´ÑƒĞ»ĞµĞ¹ â€” Ğ¸Ğ´ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ‚Ğ¾Ñ€Ñ‹, Ğ²ĞµÑ€ÑĞ¸Ğ¸, Ñ„Ğ»Ğ°Ğ³Ğ¸, ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ğ¸ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸:",
    "metadata.intro":
      "ĞšĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ğ¼Ğ¾Ğ´ÑƒĞ»ÑŒ Ğ¾Ğ±ÑŠÑĞ²Ğ»ÑĞµÑ‚ Ğ¼ĞµÑ‚Ğ°Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ, Ğ²ĞºĞ»ÑÑ‡Ğ°Ñ Ğ¸Ğ¼Ñ, Ğ²ĞµÑ€ÑĞ¸Ñ, Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ°, ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ ABI, Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ¸ Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ñ‹Ğµ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğ¼Ğ¾Ñ‡Ğ¸Ñ:",
    "trait.intro":
      "Ğ¢Ñ€ĞµĞ¹Ñ‚ Module â€” ÑÑ‚Ğ¾ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ğ¼Ğ¾Ğ´ÑƒĞ»ÑŒ â€” Ñ…ÑƒĞºĞ¸ Ğ¶Ğ¸Ğ·Ğ½ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ñ†Ğ¸ĞºĞ»Ğ°, Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹, Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ²ÑŒÑ Ğ¸ ÑĞµÑ€Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ğ´Ğ»Ñ Ğ³Ğ¾Ñ€ÑÑ‡ĞµĞ¹ Ğ¿ĞµÑ€ĞµĞ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸:",
    "registry.intro":
      "ModuleRegistry ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ Ğ²ÑĞµĞ¼Ğ¸ Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ğ½Ñ‹Ğ¼Ğ¸ Ğ¼Ğ¾Ğ´ÑƒĞ»ÑĞ¼Ğ¸ â€” Ğ¾Ğ±Ğ½Ğ°Ñ€ÑƒĞ¶ĞµĞ½Ğ¸Ğµ, Ñ€Ğ°Ğ·Ñ€ĞµÑˆĞµĞ½Ğ¸Ğµ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹, Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ°, Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¸ Ğ²Ñ‹Ğ³Ñ€ÑƒĞ·ĞºĞ°:",
    "macro.intro":
      "ĞœĞ°ĞºÑ€Ğ¾Ñ define_module! Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµÑ‚ ÑˆĞ°Ğ±Ğ»Ğ¾Ğ½Ğ½Ñ‹Ğ¹ ĞºĞ¾Ğ´ Ğ´Ğ»Ñ Ñ‚Ğ¸Ğ¿Ğ¸Ñ‡Ğ½Ñ‹Ñ… Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ğ¾Ğ² Ğ¼Ğ¾Ğ´ÑƒĞ»ĞµĞ¹ â€” Ğ¼ĞµÑ‚Ğ°Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ, Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ñ‚Ñ€ĞµĞ¹Ñ‚Ğ° Ğ¸ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ:",
    "lifecycle.intro":
      "ĞšĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ğ¼Ğ¾Ğ´ÑƒĞ»ÑŒ ÑĞ»ĞµĞ´ÑƒĞµÑ‚ ÑÑ‚Ñ€Ğ¾Ğ³Ğ¾Ğ¼Ñƒ Ğ¶Ğ¸Ğ·Ğ½ĞµĞ½Ğ½Ğ¾Ğ¼Ñƒ Ñ†Ğ¸ĞºĞ»Ñƒ Ğ¸Ğ· 9 ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğ¹ Ñ 12 Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ñ‹Ğ¼Ğ¸ Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´Ğ°Ğ¼Ğ¸. ĞšĞ¾Ğ½ĞµÑ‡Ğ½Ñ‹Ğ¹ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚ Ğ¿Ñ€ĞµĞ´Ğ¾Ñ‚Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ğ½ĞµĞ´Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ğ¼Ñ‹Ğµ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ğ¸ Ğ¾Ğ±ĞµÑĞ¿ĞµÑ‡Ğ¸Ğ²Ğ°ĞµÑ‚ Ñ‡Ğ¸ÑÑ‚ÑƒÑ Ğ³Ğ¾Ñ€ÑÑ‡ÑƒÑ Ğ¿ĞµÑ€ĞµĞ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºÑƒ:",
    "example.intro":
      "ĞŸĞ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ÑÑ‰Ğ¸Ğ¹, ĞºĞ°Ğº Ğ¼Ğ¾Ğ´ÑƒĞ»ÑŒ Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸ĞºĞ° Ñ€ĞµĞ°Ğ»Ğ¸Ğ·ÑƒĞµÑ‚ Ğ¾Ğ±Ğ° Ñ‚Ñ€ĞµĞ¹Ñ‚Ğ° Module Ğ¸ Scheduler Ñ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ¾Ğ¹ Ğ³Ğ¾Ñ€ÑÑ‡ĞµĞ¹ Ğ¿ĞµÑ€ĞµĞ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },

  ar: {
    "header.title": "Ù†Ø¸Ø§Ù… Ø§Ù„ÙˆØ­Ø¯Ø§Øª",
    "header.subtitle":
      "2,559 Ø³Ø·Ø±Ù‹Ø§ Ø¹Ø¨Ø± 9 Ù…Ù„ÙØ§Øª â€” Ø¥Ø·Ø§Ø± ÙˆØ­Ø¯Ø§Øª Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªØ¨Ø¯ÙŠÙ„ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ´ØºÙŠÙ„ØŒ Ù…Ø­ÙƒÙˆÙ… Ø¨Ø§Ù„Ù‚Ø¯Ø±Ø§ØªØŒ Ù…Ø¹ Ø¥ØµØ¯Ø§Ø± ABIØŒ ÙˆØ­Ù„ Ø§Ù„ØªØ¨Ø¹ÙŠØ§ØªØŒ ÙˆØ¢Ù„Ø© Ø­Ø§Ù„Ø© Ø¯ÙˆØ±Ø© Ø­ÙŠØ§Ø© ÙƒØ§Ù…Ù„Ø©.",
    "header.badge": "Ø¥Ø·Ø§Ø± Ø§Ù„ÙˆØ­Ø¯Ø§Øª",
    "philosophy.intro":
      "ÙÙŠ HelixØŒ ÙŠÙˆÙØ± Ù†ÙˆØ§Ø© Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø¢Ù„ÙŠØ§Øª â€” ÙˆÙ†Ø¸Ø§Ù… Ø§Ù„ÙˆØ­Ø¯Ø§Øª ÙŠÙˆÙØ± Ø§Ù„Ø³ÙŠØ§Ø³Ø§Øª. Ø§Ù„Ù…Ø¬Ø¯ÙˆÙ„Ø§ØªØŒ ÙˆØ£Ù†Ø¸Ù…Ø© Ø§Ù„Ù…Ù„ÙØ§ØªØŒ ÙˆØ§Ù„Ù…Ø´ØºÙ„Ø§ØªØŒ ÙˆÙˆØ­Ø¯Ø§Øª Ø§Ù„Ø£Ù…Ø§Ù† ÙƒÙ„Ù‡Ø§ Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªØ­Ù…ÙŠÙ„/Ø§Ù„Ø¥Ø²Ø§Ù„Ø© Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ´ØºÙŠÙ„:",
    "philosophy.mechanism.title": "ğŸ”§ Ø¢Ù„ÙŠØ© (Ø§Ù„Ù†ÙˆØ§Ø©)",
    "philosophy.policy.title": "ğŸ“‹ Ø³ÙŠØ§Ø³Ø© (Ø§Ù„ÙˆØ­Ø¯Ø§Øª)",
    "types.intro":
      "Ø£Ù†ÙˆØ§Ø¹ Ø£Ø³Ø§Ø³ÙŠØ© Ù…Ø³ØªØ®Ø¯Ù…Ø© Ø¹Ø¨Ø± Ù†Ø¸Ø§Ù… Ø§Ù„ÙˆØ­Ø¯Ø§Øª â€” Ø§Ù„Ù…Ø¹Ø±ÙØ§ØªØŒ Ø§Ù„Ø¥ØµØ¯Ø§Ø±Ø§ØªØŒ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§ØªØŒ Ø§Ù„Ø­Ø§Ù„Ø§ØªØŒ ÙˆØ§Ù„Ø£Ø®Ø·Ø§Ø¡:",
    "metadata.intro":
      "ÙƒÙ„ ÙˆØ­Ø¯Ø© ØªØ¹Ù„Ù† Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØµÙÙŠØ© ØªØ´Ù…Ù„ Ø§Ù„Ø§Ø³Ù…ØŒ Ø§Ù„Ø¥ØµØ¯Ø§Ø±ØŒ Ø§Ù„Ù…Ø¤Ù„ÙØŒ ØªÙˆØ§ÙÙ‚ ABIØŒ Ø§Ù„ØªØ¨Ø¹ÙŠØ§ØªØŒ ÙˆØ§Ù„Ù‚Ø¯Ø±Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:",
    "trait.intro":
      "Ø§Ù„Ù€ Module trait Ù‡Ùˆ Ø§Ù„Ø¹Ù‚Ø¯ Ø§Ù„Ø°ÙŠ ÙŠØ¬Ø¨ Ø£Ù† ØªÙ†ÙØ°Ù‡ ÙƒÙ„ ÙˆØ­Ø¯Ø© â€” Ø®Ø·Ø§ÙØ§Øª Ø¯ÙˆØ±Ø© Ø§Ù„Ø­ÙŠØ§Ø©ØŒ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ØŒ ÙØ­ÙˆØµØ§Øª Ø§Ù„ØµØ­Ø©ØŒ ÙˆØªØ³Ù„Ø³Ù„ Ø§Ù„Ø­Ø§Ù„Ø© Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙÙˆØ±ÙŠ:",
    "registry.intro":
      "ÙŠØ¯ÙŠØ± ModuleRegistry Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙˆØ­Ø¯Ø§Øª Ø§Ù„Ù…Ø­Ù…Ù„Ø© â€” Ø§Ù„Ø§ÙƒØªØ´Ø§ÙØŒ Ø­Ù„ Ø§Ù„ØªØ¨Ø¹ÙŠØ§ØªØŒ Ø§Ù„ØªØ­Ù…ÙŠÙ„ØŒ Ø§Ù„ØªÙ‡ÙŠØ¦Ø©ØŒ ÙˆØ§Ù„Ø¥Ø²Ø§Ù„Ø©:",
    "macro.intro":
      "Ù…Ø§ÙƒØ±Ùˆ define_module! ÙŠÙ†Ø´Ø¦ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù†Ù…Ø·ÙŠ Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„ÙˆØ­Ø¯Ø§Øª Ø§Ù„Ø´Ø§Ø¦Ø¹Ø© â€” Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆØµÙÙŠØ©ØŒ ØªÙ†ÙÙŠØ° Ø§Ù„Ù€ traitØŒ ÙˆØ§Ù„ØªØ³Ø¬ÙŠÙ„:",
    "lifecycle.intro":
      "ÙƒÙ„ ÙˆØ­Ø¯Ø© ØªØªØ¨Ø¹ Ø¯ÙˆØ±Ø© Ø­ÙŠØ§Ø© ØµØ§Ø±Ù…Ø© Ù…Ù† 9 Ø­Ø§Ù„Ø§Øª Ù…Ø¹ 12 Ø§Ù†ØªÙ‚Ø§Ù„Ù‹Ø§ Ù…Ù…ÙƒÙ†Ù‹Ø§. Ø¢Ù„Ø© Ø§Ù„Ø­Ø§Ù„Ø© ØªÙ…Ù†Ø¹ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª ØºÙŠØ± Ø§Ù„ØµØ§Ù„Ø­Ø© ÙˆØªÙ…ÙƒÙ† Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙÙˆØ±ÙŠ Ø§Ù„Ù†Ø¸ÙŠÙ:",
    "example.intro":
      "Ù…Ø«Ø§Ù„ ÙƒØ§Ù…Ù„ ÙŠÙˆØ¶Ø­ ÙƒÙŠÙ ØªÙ†ÙØ° ÙˆØ­Ø¯Ø© Ø§Ù„Ù…Ø¬Ø¯ÙˆÙ„ ÙƒÙ„Ø§Ù‹ Ù…Ù† Ø§Ù„Ù€ Module trait ÙˆØ§Ù„Ù€ Scheduler traitØŒ Ù…Ø¹ Ø¯Ø¹Ù… Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙÙˆØ±ÙŠ:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },
  zh: {
    "header.title": "æ¨¡å—ç³»ç»Ÿ",
    "header.subtitle": "2,559 lines across 9 files â€” a hot-swappable, capability-gated module framework with ABI versioning, dependency resolution, and a full lifecycle state machine.",
    "header.badge": "MODULE FRAMEWORK",
    "philosophy.intro": "In Helix, the core kernel provides mechanisms â€” the module system provides policy. Schedulers, filesystems, drivers, and security modules are all loadable/unloadable at runtime:",
    "philosophy.mechanism.title": "ğŸ”§ Mechanism (Core)",
    "philosophy.policy.title": "ğŸ“‹ Policy (Modules)",
    "types.intro": "Core types used across the module system â€” identifiers, versions, flags, states, and errors:",
    "metadata.intro": "Every module declares metadata including name, version, author, ABI compatibility, dependencies, and required capabilities:",
    "trait.intro": "The Module trait is the contract every module must implement â€” lifecycle hooks, message handling, health checks, and state serialization for hot-reload:",
    "registry.intro": "The ModuleRegistry manages all loaded modules â€” discovery, dependency resolution, loading, initialization, and unloading:",
    "macro.intro": "The define_module! macro generates boilerplate for common module patterns â€” metadata, trait implementation, and registration:",
    "lifecycle.intro": "Every module follows a strict 9-state lifecycle with 12 possible transitions. The state machine prevents invalid operations and enables clean hot-reload:",
    "example.intro": "A complete example showing how a scheduler module implements both the Module trait and the Scheduler trait, with hot-reload support:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },
  ja: {
    "header.title": "ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚·ã‚¹ãƒ†ãƒ ",
    "header.subtitle": "2,559 lines across 9 files â€” a hot-swappable, capability-gated module framework with ABI versioning, dependency resolution, and a full lifecycle state machine.",
    "header.badge": "MODULE FRAMEWORK",
    "philosophy.intro": "In Helix, the core kernel provides mechanisms â€” the module system provides policy. Schedulers, filesystems, drivers, and security modules are all loadable/unloadable at runtime:",
    "philosophy.mechanism.title": "ğŸ”§ Mechanism (Core)",
    "philosophy.policy.title": "ğŸ“‹ Policy (Modules)",
    "types.intro": "Core types used across the module system â€” identifiers, versions, flags, states, and errors:",
    "metadata.intro": "Every module declares metadata including name, version, author, ABI compatibility, dependencies, and required capabilities:",
    "trait.intro": "The Module trait is the contract every module must implement â€” lifecycle hooks, message handling, health checks, and state serialization for hot-reload:",
    "registry.intro": "The ModuleRegistry manages all loaded modules â€” discovery, dependency resolution, loading, initialization, and unloading:",
    "macro.intro": "The define_module! macro generates boilerplate for common module patterns â€” metadata, trait implementation, and registration:",
    "lifecycle.intro": "Every module follows a strict 9-state lifecycle with 12 possible transitions. The state machine prevents invalid operations and enables clean hot-reload:",
    "example.intro": "A complete example showing how a scheduler module implements both the Module trait and the Scheduler trait, with hot-reload support:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },
  ko: {
    "header.title": "ëª¨ë“ˆ ì‹œìŠ¤í…œ",
    "header.subtitle": "2,559 lines across 9 files â€” a hot-swappable, capability-gated module framework with ABI versioning, dependency resolution, and a full lifecycle state machine.",
    "header.badge": "MODULE FRAMEWORK",
    "philosophy.intro": "In Helix, the core kernel provides mechanisms â€” the module system provides policy. Schedulers, filesystems, drivers, and security modules are all loadable/unloadable at runtime:",
    "philosophy.mechanism.title": "ğŸ”§ Mechanism (Core)",
    "philosophy.policy.title": "ğŸ“‹ Policy (Modules)",
    "types.intro": "Core types used across the module system â€” identifiers, versions, flags, states, and errors:",
    "metadata.intro": "Every module declares metadata including name, version, author, ABI compatibility, dependencies, and required capabilities:",
    "trait.intro": "The Module trait is the contract every module must implement â€” lifecycle hooks, message handling, health checks, and state serialization for hot-reload:",
    "registry.intro": "The ModuleRegistry manages all loaded modules â€” discovery, dependency resolution, loading, initialization, and unloading:",
    "macro.intro": "The define_module! macro generates boilerplate for common module patterns â€” metadata, trait implementation, and registration:",
    "lifecycle.intro": "Every module follows a strict 9-state lifecycle with 12 possible transitions. The state machine prevents invalid operations and enables clean hot-reload:",
    "example.intro": "A complete example showing how a scheduler module implements both the Module trait and the Scheduler trait, with hot-reload support:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },
  hi: {
    "header.title": "à¤®à¥‰à¤¡à¥à¤¯à¥‚à¤² à¤¸à¤¿à¤¸à¥à¤Ÿà¤®",
    "header.subtitle": "2,559 lines across 9 files â€” a hot-swappable, capability-gated module framework with ABI versioning, dependency resolution, and a full lifecycle state machine.",
    "header.badge": "MODULE FRAMEWORK",
    "philosophy.intro": "In Helix, the core kernel provides mechanisms â€” the module system provides policy. Schedulers, filesystems, drivers, and security modules are all loadable/unloadable at runtime:",
    "philosophy.mechanism.title": "ğŸ”§ Mechanism (Core)",
    "philosophy.policy.title": "ğŸ“‹ Policy (Modules)",
    "types.intro": "Core types used across the module system â€” identifiers, versions, flags, states, and errors:",
    "metadata.intro": "Every module declares metadata including name, version, author, ABI compatibility, dependencies, and required capabilities:",
    "trait.intro": "The Module trait is the contract every module must implement â€” lifecycle hooks, message handling, health checks, and state serialization for hot-reload:",
    "registry.intro": "The ModuleRegistry manages all loaded modules â€” discovery, dependency resolution, loading, initialization, and unloading:",
    "macro.intro": "The define_module! macro generates boilerplate for common module patterns â€” metadata, trait implementation, and registration:",
    "lifecycle.intro": "Every module follows a strict 9-state lifecycle with 12 possible transitions. The state machine prevents invalid operations and enables clean hot-reload:",
    "example.intro": "A complete example showing how a scheduler module implements both the Module trait and the Scheduler trait, with hot-reload support:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },
  it: {
    "header.title": "Sistema di Moduli",
    "header.subtitle": "2,559 lines across 9 files â€” a hot-swappable, capability-gated module framework with ABI versioning, dependency resolution, and a full lifecycle state machine.",
    "header.badge": "MODULE FRAMEWORK",
    "philosophy.intro": "In Helix, the core kernel provides mechanisms â€” the module system provides policy. Schedulers, filesystems, drivers, and security modules are all loadable/unloadable at runtime:",
    "philosophy.mechanism.title": "ğŸ”§ Mechanism (Core)",
    "philosophy.policy.title": "ğŸ“‹ Policy (Modules)",
    "types.intro": "Core types used across the module system â€” identifiers, versions, flags, states, and errors:",
    "metadata.intro": "Every module declares metadata including name, version, author, ABI compatibility, dependencies, and required capabilities:",
    "trait.intro": "The Module trait is the contract every module must implement â€” lifecycle hooks, message handling, health checks, and state serialization for hot-reload:",
    "registry.intro": "The ModuleRegistry manages all loaded modules â€” discovery, dependency resolution, loading, initialization, and unloading:",
    "macro.intro": "The define_module! macro generates boilerplate for common module patterns â€” metadata, trait implementation, and registration:",
    "lifecycle.intro": "Every module follows a strict 9-state lifecycle with 12 possible transitions. The state machine prevents invalid operations and enables clean hot-reload:",
    "example.intro": "A complete example showing how a scheduler module implements both the Module trait and the Scheduler trait, with hot-reload support:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },
  nl: {
    "header.title": "Modulesysteem",
    "header.subtitle": "2,559 lines across 9 files â€” a hot-swappable, capability-gated module framework with ABI versioning, dependency resolution, and a full lifecycle state machine.",
    "header.badge": "MODULE FRAMEWORK",
    "philosophy.intro": "In Helix, the core kernel provides mechanisms â€” the module system provides policy. Schedulers, filesystems, drivers, and security modules are all loadable/unloadable at runtime:",
    "philosophy.mechanism.title": "ğŸ”§ Mechanism (Core)",
    "philosophy.policy.title": "ğŸ“‹ Policy (Modules)",
    "types.intro": "Core types used across the module system â€” identifiers, versions, flags, states, and errors:",
    "metadata.intro": "Every module declares metadata including name, version, author, ABI compatibility, dependencies, and required capabilities:",
    "trait.intro": "The Module trait is the contract every module must implement â€” lifecycle hooks, message handling, health checks, and state serialization for hot-reload:",
    "registry.intro": "The ModuleRegistry manages all loaded modules â€” discovery, dependency resolution, loading, initialization, and unloading:",
    "macro.intro": "The define_module! macro generates boilerplate for common module patterns â€” metadata, trait implementation, and registration:",
    "lifecycle.intro": "Every module follows a strict 9-state lifecycle with 12 possible transitions. The state machine prevents invalid operations and enables clean hot-reload:",
    "example.intro": "A complete example showing how a scheduler module implements both the Module trait and the Scheduler trait, with hot-reload support:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },
  pl: {
    "header.title": "System ModuÅ‚Ã³w",
    "header.subtitle": "2,559 lines across 9 files â€” a hot-swappable, capability-gated module framework with ABI versioning, dependency resolution, and a full lifecycle state machine.",
    "header.badge": "MODULE FRAMEWORK",
    "philosophy.intro": "In Helix, the core kernel provides mechanisms â€” the module system provides policy. Schedulers, filesystems, drivers, and security modules are all loadable/unloadable at runtime:",
    "philosophy.mechanism.title": "ğŸ”§ Mechanism (Core)",
    "philosophy.policy.title": "ğŸ“‹ Policy (Modules)",
    "types.intro": "Core types used across the module system â€” identifiers, versions, flags, states, and errors:",
    "metadata.intro": "Every module declares metadata including name, version, author, ABI compatibility, dependencies, and required capabilities:",
    "trait.intro": "The Module trait is the contract every module must implement â€” lifecycle hooks, message handling, health checks, and state serialization for hot-reload:",
    "registry.intro": "The ModuleRegistry manages all loaded modules â€” discovery, dependency resolution, loading, initialization, and unloading:",
    "macro.intro": "The define_module! macro generates boilerplate for common module patterns â€” metadata, trait implementation, and registration:",
    "lifecycle.intro": "Every module follows a strict 9-state lifecycle with 12 possible transitions. The state machine prevents invalid operations and enables clean hot-reload:",
    "example.intro": "A complete example showing how a scheduler module implements both the Module trait and the Scheduler trait, with hot-reload support:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },
  sv: {
    "header.title": "Modulsystem",
    "header.subtitle": "2,559 lines across 9 files â€” a hot-swappable, capability-gated module framework with ABI versioning, dependency resolution, and a full lifecycle state machine.",
    "header.badge": "MODULE FRAMEWORK",
    "philosophy.intro": "In Helix, the core kernel provides mechanisms â€” the module system provides policy. Schedulers, filesystems, drivers, and security modules are all loadable/unloadable at runtime:",
    "philosophy.mechanism.title": "ğŸ”§ Mechanism (Core)",
    "philosophy.policy.title": "ğŸ“‹ Policy (Modules)",
    "types.intro": "Core types used across the module system â€” identifiers, versions, flags, states, and errors:",
    "metadata.intro": "Every module declares metadata including name, version, author, ABI compatibility, dependencies, and required capabilities:",
    "trait.intro": "The Module trait is the contract every module must implement â€” lifecycle hooks, message handling, health checks, and state serialization for hot-reload:",
    "registry.intro": "The ModuleRegistry manages all loaded modules â€” discovery, dependency resolution, loading, initialization, and unloading:",
    "macro.intro": "The define_module! macro generates boilerplate for common module patterns â€” metadata, trait implementation, and registration:",
    "lifecycle.intro": "Every module follows a strict 9-state lifecycle with 12 possible transitions. The state machine prevents invalid operations and enables clean hot-reload:",
    "example.intro": "A complete example showing how a scheduler module implements both the Module trait and the Scheduler trait, with hot-reload support:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },
  tr: {
    "header.title": "ModÃ¼l Sistemi",
    "header.subtitle": "2,559 lines across 9 files â€” a hot-swappable, capability-gated module framework with ABI versioning, dependency resolution, and a full lifecycle state machine.",
    "header.badge": "MODULE FRAMEWORK",
    "philosophy.intro": "In Helix, the core kernel provides mechanisms â€” the module system provides policy. Schedulers, filesystems, drivers, and security modules are all loadable/unloadable at runtime:",
    "philosophy.mechanism.title": "ğŸ”§ Mechanism (Core)",
    "philosophy.policy.title": "ğŸ“‹ Policy (Modules)",
    "types.intro": "Core types used across the module system â€” identifiers, versions, flags, states, and errors:",
    "metadata.intro": "Every module declares metadata including name, version, author, ABI compatibility, dependencies, and required capabilities:",
    "trait.intro": "The Module trait is the contract every module must implement â€” lifecycle hooks, message handling, health checks, and state serialization for hot-reload:",
    "registry.intro": "The ModuleRegistry manages all loaded modules â€” discovery, dependency resolution, loading, initialization, and unloading:",
    "macro.intro": "The define_module! macro generates boilerplate for common module patterns â€” metadata, trait implementation, and registration:",
    "lifecycle.intro": "Every module follows a strict 9-state lifecycle with 12 possible transitions. The state machine prevents invalid operations and enables clean hot-reload:",
    "example.intro": "A complete example showing how a scheduler module implements both the Module trait and the Scheduler trait, with hot-reload support:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },
  uk: {
    "header.title": "Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° ĞœĞ¾Ğ´ÑƒĞ»Ñ–Ğ²",
    "header.subtitle": "2,559 lines across 9 files â€” a hot-swappable, capability-gated module framework with ABI versioning, dependency resolution, and a full lifecycle state machine.",
    "header.badge": "MODULE FRAMEWORK",
    "philosophy.intro": "In Helix, the core kernel provides mechanisms â€” the module system provides policy. Schedulers, filesystems, drivers, and security modules are all loadable/unloadable at runtime:",
    "philosophy.mechanism.title": "ğŸ”§ Mechanism (Core)",
    "philosophy.policy.title": "ğŸ“‹ Policy (Modules)",
    "types.intro": "Core types used across the module system â€” identifiers, versions, flags, states, and errors:",
    "metadata.intro": "Every module declares metadata including name, version, author, ABI compatibility, dependencies, and required capabilities:",
    "trait.intro": "The Module trait is the contract every module must implement â€” lifecycle hooks, message handling, health checks, and state serialization for hot-reload:",
    "registry.intro": "The ModuleRegistry manages all loaded modules â€” discovery, dependency resolution, loading, initialization, and unloading:",
    "macro.intro": "The define_module! macro generates boilerplate for common module patterns â€” metadata, trait implementation, and registration:",
    "lifecycle.intro": "Every module follows a strict 9-state lifecycle with 12 possible transitions. The state machine prevents invalid operations and enables clean hot-reload:",
    "example.intro": "A complete example showing how a scheduler module implements both the Module trait and the Scheduler trait, with hot-reload support:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },
  th: {
    "header.title": "à¸£à¸°à¸šà¸šà¹‚à¸¡à¸”à¸¹à¸¥",
    "header.subtitle": "2,559 lines across 9 files â€” a hot-swappable, capability-gated module framework with ABI versioning, dependency resolution, and a full lifecycle state machine.",
    "header.badge": "MODULE FRAMEWORK",
    "philosophy.intro": "In Helix, the core kernel provides mechanisms â€” the module system provides policy. Schedulers, filesystems, drivers, and security modules are all loadable/unloadable at runtime:",
    "philosophy.mechanism.title": "ğŸ”§ Mechanism (Core)",
    "philosophy.policy.title": "ğŸ“‹ Policy (Modules)",
    "types.intro": "Core types used across the module system â€” identifiers, versions, flags, states, and errors:",
    "metadata.intro": "Every module declares metadata including name, version, author, ABI compatibility, dependencies, and required capabilities:",
    "trait.intro": "The Module trait is the contract every module must implement â€” lifecycle hooks, message handling, health checks, and state serialization for hot-reload:",
    "registry.intro": "The ModuleRegistry manages all loaded modules â€” discovery, dependency resolution, loading, initialization, and unloading:",
    "macro.intro": "The define_module! macro generates boilerplate for common module patterns â€” metadata, trait implementation, and registration:",
    "lifecycle.intro": "Every module follows a strict 9-state lifecycle with 12 possible transitions. The state machine prevents invalid operations and enables clean hot-reload:",
    "example.intro": "A complete example showing how a scheduler module implements both the Module trait and the Scheduler trait, with hot-reload support:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },
  vi: {
    "header.title": "Há»‡ thá»‘ng Module",
    "header.subtitle": "2,559 lines across 9 files â€” a hot-swappable, capability-gated module framework with ABI versioning, dependency resolution, and a full lifecycle state machine.",
    "header.badge": "MODULE FRAMEWORK",
    "philosophy.intro": "In Helix, the core kernel provides mechanisms â€” the module system provides policy. Schedulers, filesystems, drivers, and security modules are all loadable/unloadable at runtime:",
    "philosophy.mechanism.title": "ğŸ”§ Mechanism (Core)",
    "philosophy.policy.title": "ğŸ“‹ Policy (Modules)",
    "types.intro": "Core types used across the module system â€” identifiers, versions, flags, states, and errors:",
    "metadata.intro": "Every module declares metadata including name, version, author, ABI compatibility, dependencies, and required capabilities:",
    "trait.intro": "The Module trait is the contract every module must implement â€” lifecycle hooks, message handling, health checks, and state serialization for hot-reload:",
    "registry.intro": "The ModuleRegistry manages all loaded modules â€” discovery, dependency resolution, loading, initialization, and unloading:",
    "macro.intro": "The define_module! macro generates boilerplate for common module patterns â€” metadata, trait implementation, and registration:",
    "lifecycle.intro": "Every module follows a strict 9-state lifecycle with 12 possible transitions. The state machine prevents invalid operations and enables clean hot-reload:",
    "example.intro": "A complete example showing how a scheduler module implements both the Module trait and the Scheduler trait, with hot-reload support:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },
  id: {
    "header.title": "Sistem Modul",
    "header.subtitle": "2,559 lines across 9 files â€” a hot-swappable, capability-gated module framework with ABI versioning, dependency resolution, and a full lifecycle state machine.",
    "header.badge": "MODULE FRAMEWORK",
    "philosophy.intro": "In Helix, the core kernel provides mechanisms â€” the module system provides policy. Schedulers, filesystems, drivers, and security modules are all loadable/unloadable at runtime:",
    "philosophy.mechanism.title": "ğŸ”§ Mechanism (Core)",
    "philosophy.policy.title": "ğŸ“‹ Policy (Modules)",
    "types.intro": "Core types used across the module system â€” identifiers, versions, flags, states, and errors:",
    "metadata.intro": "Every module declares metadata including name, version, author, ABI compatibility, dependencies, and required capabilities:",
    "trait.intro": "The Module trait is the contract every module must implement â€” lifecycle hooks, message handling, health checks, and state serialization for hot-reload:",
    "registry.intro": "The ModuleRegistry manages all loaded modules â€” discovery, dependency resolution, loading, initialization, and unloading:",
    "macro.intro": "The define_module! macro generates boilerplate for common module patterns â€” metadata, trait implementation, and registration:",
    "lifecycle.intro": "Every module follows a strict 9-state lifecycle with 12 possible transitions. The state machine prevents invalid operations and enables clean hot-reload:",
    "example.intro": "A complete example showing how a scheduler module implements both the Module trait and the Scheduler trait, with hot-reload support:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },
  cs: {
    "header.title": "SystÃ©m ModulÅ¯",
    "header.subtitle": "2,559 lines across 9 files â€” a hot-swappable, capability-gated module framework with ABI versioning, dependency resolution, and a full lifecycle state machine.",
    "header.badge": "MODULE FRAMEWORK",
    "philosophy.intro": "In Helix, the core kernel provides mechanisms â€” the module system provides policy. Schedulers, filesystems, drivers, and security modules are all loadable/unloadable at runtime:",
    "philosophy.mechanism.title": "ğŸ”§ Mechanism (Core)",
    "philosophy.policy.title": "ğŸ“‹ Policy (Modules)",
    "types.intro": "Core types used across the module system â€” identifiers, versions, flags, states, and errors:",
    "metadata.intro": "Every module declares metadata including name, version, author, ABI compatibility, dependencies, and required capabilities:",
    "trait.intro": "The Module trait is the contract every module must implement â€” lifecycle hooks, message handling, health checks, and state serialization for hot-reload:",
    "registry.intro": "The ModuleRegistry manages all loaded modules â€” discovery, dependency resolution, loading, initialization, and unloading:",
    "macro.intro": "The define_module! macro generates boilerplate for common module patterns â€” metadata, trait implementation, and registration:",
    "lifecycle.intro": "Every module follows a strict 9-state lifecycle with 12 possible transitions. The state machine prevents invalid operations and enables clean hot-reload:",
    "example.intro": "A complete example showing how a scheduler module implements both the Module trait and the Scheduler trait, with hot-reload support:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },
  ro: {
    "header.title": "Sistem de Module",
    "header.subtitle": "2,559 lines across 9 files â€” a hot-swappable, capability-gated module framework with ABI versioning, dependency resolution, and a full lifecycle state machine.",
    "header.badge": "MODULE FRAMEWORK",
    "philosophy.intro": "In Helix, the core kernel provides mechanisms â€” the module system provides policy. Schedulers, filesystems, drivers, and security modules are all loadable/unloadable at runtime:",
    "philosophy.mechanism.title": "ğŸ”§ Mechanism (Core)",
    "philosophy.policy.title": "ğŸ“‹ Policy (Modules)",
    "types.intro": "Core types used across the module system â€” identifiers, versions, flags, states, and errors:",
    "metadata.intro": "Every module declares metadata including name, version, author, ABI compatibility, dependencies, and required capabilities:",
    "trait.intro": "The Module trait is the contract every module must implement â€” lifecycle hooks, message handling, health checks, and state serialization for hot-reload:",
    "registry.intro": "The ModuleRegistry manages all loaded modules â€” discovery, dependency resolution, loading, initialization, and unloading:",
    "macro.intro": "The define_module! macro generates boilerplate for common module patterns â€” metadata, trait implementation, and registration:",
    "lifecycle.intro": "Every module follows a strict 9-state lifecycle with 12 possible transitions. The state machine prevents invalid operations and enables clean hot-reload:",
    "example.intro": "A complete example showing how a scheduler module implements both the Module trait and the Scheduler trait, with hot-reload support:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },
  hu: {
    "header.title": "Modulrendszer",
    "header.subtitle": "2,559 lines across 9 files â€” a hot-swappable, capability-gated module framework with ABI versioning, dependency resolution, and a full lifecycle state machine.",
    "header.badge": "MODULE FRAMEWORK",
    "philosophy.intro": "In Helix, the core kernel provides mechanisms â€” the module system provides policy. Schedulers, filesystems, drivers, and security modules are all loadable/unloadable at runtime:",
    "philosophy.mechanism.title": "ğŸ”§ Mechanism (Core)",
    "philosophy.policy.title": "ğŸ“‹ Policy (Modules)",
    "types.intro": "Core types used across the module system â€” identifiers, versions, flags, states, and errors:",
    "metadata.intro": "Every module declares metadata including name, version, author, ABI compatibility, dependencies, and required capabilities:",
    "trait.intro": "The Module trait is the contract every module must implement â€” lifecycle hooks, message handling, health checks, and state serialization for hot-reload:",
    "registry.intro": "The ModuleRegistry manages all loaded modules â€” discovery, dependency resolution, loading, initialization, and unloading:",
    "macro.intro": "The define_module! macro generates boilerplate for common module patterns â€” metadata, trait implementation, and registration:",
    "lifecycle.intro": "Every module follows a strict 9-state lifecycle with 12 possible transitions. The state machine prevents invalid operations and enables clean hot-reload:",
    "example.intro": "A complete example showing how a scheduler module implements both the Module trait and the Scheduler trait, with hot-reload support:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },
  el: {
    "header.title": "Î£ÏÏƒÏ„Î·Î¼Î± Modules",
    "header.subtitle": "2,559 lines across 9 files â€” a hot-swappable, capability-gated module framework with ABI versioning, dependency resolution, and a full lifecycle state machine.",
    "header.badge": "MODULE FRAMEWORK",
    "philosophy.intro": "In Helix, the core kernel provides mechanisms â€” the module system provides policy. Schedulers, filesystems, drivers, and security modules are all loadable/unloadable at runtime:",
    "philosophy.mechanism.title": "ğŸ”§ Mechanism (Core)",
    "philosophy.policy.title": "ğŸ“‹ Policy (Modules)",
    "types.intro": "Core types used across the module system â€” identifiers, versions, flags, states, and errors:",
    "metadata.intro": "Every module declares metadata including name, version, author, ABI compatibility, dependencies, and required capabilities:",
    "trait.intro": "The Module trait is the contract every module must implement â€” lifecycle hooks, message handling, health checks, and state serialization for hot-reload:",
    "registry.intro": "The ModuleRegistry manages all loaded modules â€” discovery, dependency resolution, loading, initialization, and unloading:",
    "macro.intro": "The define_module! macro generates boilerplate for common module patterns â€” metadata, trait implementation, and registration:",
    "lifecycle.intro": "Every module follows a strict 9-state lifecycle with 12 possible transitions. The state machine prevents invalid operations and enables clean hot-reload:",
    "example.intro": "A complete example showing how a scheduler module implements both the Module trait and the Scheduler trait, with hot-reload support:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },
  he: {
    "header.title": "××¢×¨×›×ª ××•×“×•×œ×™×",
    "header.subtitle": "2,559 lines across 9 files â€” a hot-swappable, capability-gated module framework with ABI versioning, dependency resolution, and a full lifecycle state machine.",
    "header.badge": "MODULE FRAMEWORK",
    "philosophy.intro": "In Helix, the core kernel provides mechanisms â€” the module system provides policy. Schedulers, filesystems, drivers, and security modules are all loadable/unloadable at runtime:",
    "philosophy.mechanism.title": "ğŸ”§ Mechanism (Core)",
    "philosophy.policy.title": "ğŸ“‹ Policy (Modules)",
    "types.intro": "Core types used across the module system â€” identifiers, versions, flags, states, and errors:",
    "metadata.intro": "Every module declares metadata including name, version, author, ABI compatibility, dependencies, and required capabilities:",
    "trait.intro": "The Module trait is the contract every module must implement â€” lifecycle hooks, message handling, health checks, and state serialization for hot-reload:",
    "registry.intro": "The ModuleRegistry manages all loaded modules â€” discovery, dependency resolution, loading, initialization, and unloading:",
    "macro.intro": "The define_module! macro generates boilerplate for common module patterns â€” metadata, trait implementation, and registration:",
    "lifecycle.intro": "Every module follows a strict 9-state lifecycle with 12 possible transitions. The state machine prevents invalid operations and enables clean hot-reload:",
    "example.intro": "A complete example showing how a scheduler module implements both the Module trait and the Scheduler trait, with hot-reload support:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },
  bn: {
    "header.title": "à¦®à¦¡à¦¿à¦‰à¦² à¦¸à¦¿à¦¸à§à¦Ÿà§‡à¦®",
    "header.subtitle": "2,559 lines across 9 files â€” a hot-swappable, capability-gated module framework with ABI versioning, dependency resolution, and a full lifecycle state machine.",
    "header.badge": "MODULE FRAMEWORK",
    "philosophy.intro": "In Helix, the core kernel provides mechanisms â€” the module system provides policy. Schedulers, filesystems, drivers, and security modules are all loadable/unloadable at runtime:",
    "philosophy.mechanism.title": "ğŸ”§ Mechanism (Core)",
    "philosophy.policy.title": "ğŸ“‹ Policy (Modules)",
    "types.intro": "Core types used across the module system â€” identifiers, versions, flags, states, and errors:",
    "metadata.intro": "Every module declares metadata including name, version, author, ABI compatibility, dependencies, and required capabilities:",
    "trait.intro": "The Module trait is the contract every module must implement â€” lifecycle hooks, message handling, health checks, and state serialization for hot-reload:",
    "registry.intro": "The ModuleRegistry manages all loaded modules â€” discovery, dependency resolution, loading, initialization, and unloading:",
    "macro.intro": "The define_module! macro generates boilerplate for common module patterns â€” metadata, trait implementation, and registration:",
    "lifecycle.intro": "Every module follows a strict 9-state lifecycle with 12 possible transitions. The state machine prevents invalid operations and enables clean hot-reload:",
    "example.intro": "A complete example showing how a scheduler module implements both the Module trait and the Scheduler trait, with hot-reload support:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },
  ms: {
    "header.title": "Sistem Modul",
    "header.subtitle": "2,559 lines across 9 files â€” a hot-swappable, capability-gated module framework with ABI versioning, dependency resolution, and a full lifecycle state machine.",
    "header.badge": "MODULE FRAMEWORK",
    "philosophy.intro": "In Helix, the core kernel provides mechanisms â€” the module system provides policy. Schedulers, filesystems, drivers, and security modules are all loadable/unloadable at runtime:",
    "philosophy.mechanism.title": "ğŸ”§ Mechanism (Core)",
    "philosophy.policy.title": "ğŸ“‹ Policy (Modules)",
    "types.intro": "Core types used across the module system â€” identifiers, versions, flags, states, and errors:",
    "metadata.intro": "Every module declares metadata including name, version, author, ABI compatibility, dependencies, and required capabilities:",
    "trait.intro": "The Module trait is the contract every module must implement â€” lifecycle hooks, message handling, health checks, and state serialization for hot-reload:",
    "registry.intro": "The ModuleRegistry manages all loaded modules â€” discovery, dependency resolution, loading, initialization, and unloading:",
    "macro.intro": "The define_module! macro generates boilerplate for common module patterns â€” metadata, trait implementation, and registration:",
    "lifecycle.intro": "Every module follows a strict 9-state lifecycle with 12 possible transitions. The state machine prevents invalid operations and enables clean hot-reload:",
    "example.intro": "A complete example showing how a scheduler module implements both the Module trait and the Scheduler trait, with hot-reload support:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },
  fi: {
    "header.title": "ModuulijÃ¤rjestelmÃ¤",
    "header.subtitle": "2,559 lines across 9 files â€” a hot-swappable, capability-gated module framework with ABI versioning, dependency resolution, and a full lifecycle state machine.",
    "header.badge": "MODULE FRAMEWORK",
    "philosophy.intro": "In Helix, the core kernel provides mechanisms â€” the module system provides policy. Schedulers, filesystems, drivers, and security modules are all loadable/unloadable at runtime:",
    "philosophy.mechanism.title": "ğŸ”§ Mechanism (Core)",
    "philosophy.policy.title": "ğŸ“‹ Policy (Modules)",
    "types.intro": "Core types used across the module system â€” identifiers, versions, flags, states, and errors:",
    "metadata.intro": "Every module declares metadata including name, version, author, ABI compatibility, dependencies, and required capabilities:",
    "trait.intro": "The Module trait is the contract every module must implement â€” lifecycle hooks, message handling, health checks, and state serialization for hot-reload:",
    "registry.intro": "The ModuleRegistry manages all loaded modules â€” discovery, dependency resolution, loading, initialization, and unloading:",
    "macro.intro": "The define_module! macro generates boilerplate for common module patterns â€” metadata, trait implementation, and registration:",
    "lifecycle.intro": "Every module follows a strict 9-state lifecycle with 12 possible transitions. The state machine prevents invalid operations and enables clean hot-reload:",
    "example.intro": "A complete example showing how a scheduler module implements both the Module trait and the Scheduler trait, with hot-reload support:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },
  da: {
    "header.title": "Modulsystem",
    "header.subtitle": "2,559 lines across 9 files â€” a hot-swappable, capability-gated module framework with ABI versioning, dependency resolution, and a full lifecycle state machine.",
    "header.badge": "MODULE FRAMEWORK",
    "philosophy.intro": "In Helix, the core kernel provides mechanisms â€” the module system provides policy. Schedulers, filesystems, drivers, and security modules are all loadable/unloadable at runtime:",
    "philosophy.mechanism.title": "ğŸ”§ Mechanism (Core)",
    "philosophy.policy.title": "ğŸ“‹ Policy (Modules)",
    "types.intro": "Core types used across the module system â€” identifiers, versions, flags, states, and errors:",
    "metadata.intro": "Every module declares metadata including name, version, author, ABI compatibility, dependencies, and required capabilities:",
    "trait.intro": "The Module trait is the contract every module must implement â€” lifecycle hooks, message handling, health checks, and state serialization for hot-reload:",
    "registry.intro": "The ModuleRegistry manages all loaded modules â€” discovery, dependency resolution, loading, initialization, and unloading:",
    "macro.intro": "The define_module! macro generates boilerplate for common module patterns â€” metadata, trait implementation, and registration:",
    "lifecycle.intro": "Every module follows a strict 9-state lifecycle with 12 possible transitions. The state machine prevents invalid operations and enables clean hot-reload:",
    "example.intro": "A complete example showing how a scheduler module implements both the Module trait and the Scheduler trait, with hot-reload support:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },
  no: {
    "header.title": "Modulsystem",
    "header.subtitle": "2,559 lines across 9 files â€” a hot-swappable, capability-gated module framework with ABI versioning, dependency resolution, and a full lifecycle state machine.",
    "header.badge": "MODULE FRAMEWORK",
    "philosophy.intro": "In Helix, the core kernel provides mechanisms â€” the module system provides policy. Schedulers, filesystems, drivers, and security modules are all loadable/unloadable at runtime:",
    "philosophy.mechanism.title": "ğŸ”§ Mechanism (Core)",
    "philosophy.policy.title": "ğŸ“‹ Policy (Modules)",
    "types.intro": "Core types used across the module system â€” identifiers, versions, flags, states, and errors:",
    "metadata.intro": "Every module declares metadata including name, version, author, ABI compatibility, dependencies, and required capabilities:",
    "trait.intro": "The Module trait is the contract every module must implement â€” lifecycle hooks, message handling, health checks, and state serialization for hot-reload:",
    "registry.intro": "The ModuleRegistry manages all loaded modules â€” discovery, dependency resolution, loading, initialization, and unloading:",
    "macro.intro": "The define_module! macro generates boilerplate for common module patterns â€” metadata, trait implementation, and registration:",
    "lifecycle.intro": "Every module follows a strict 9-state lifecycle with 12 possible transitions. The state machine prevents invalid operations and enables clean hot-reload:",
    "example.intro": "A complete example showing how a scheduler module implements both the Module trait and the Scheduler trait, with hot-reload support:",
    "section.philosophy": "Philosophy",
    "section.types": "Core Types",
    "section.metadata": "Module Metadata",
    "section.trait": "Module Trait",
    "section.registry": "Module Registry",
    "section.macro": "define_module! Macro",
    "section.lifecycle": "Module Lifecycle",
    "section.example": "Example: Round-Robin Scheduler",
  },
};

export default content;
